/*
McKay Madsen
Lab 7

Memory Simulator
Functions as a cache. Supports direct mapping, x-way set associativity (2,4,...), and fully associative
Supports LRU and FIFO replacement policies and uses write-back.
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>

void query_user(int specs[], char filename[]);
void simulator_output(int specs[], int file_data_mem[], char file_data_op[]);
void print_table_1(int specs[], int file_data_mem[], char file_data_op[], int tag_bits, int cache[][7]);
void print_table_2(int specs[], int file_data_mem[], int tag_bits, int cache[][7]);
int binary_conversion(int num);
void writeback(char file_data_op[], int cache[][7], int write_back_help, int mm_blk_num[], int cm_blk_num[], int i);
double best_hit_rate(int file_data_mem[], int specs[]);

int main(int argc, char* argv[]){
    
    char filename[64];
    char loop = 'y';
    int specs[6] = {0,0,0,0,0,0};                               //array to store user specifications
    /* User specs array:
     * 0 = memory_size
     * 1 = cache_size
     * 2 = blk_size
     * 3 = degree
     * 4 = replace (1 = LRU, 2 = FIFO)
     * 5 = num of ops in file
     */
     
    while(loop == 'y'){
    
        query_user(specs, filename);                            //get needed specs from user
        
        FILE *fptr = fopen(filename, "r");                      //open data file
        if (fptr == NULL) {                                     //file error
            printf("Cannot open file \n");
            exit(0); 
        }

        int i = 0, j = 0, k = 0;                                //variables for loops
        char temp = NULL;                   
        int temp2 = 0;
        int num_ops = 0;
        
        int result = fscanf(fptr,"%d",&num_ops);                //scan number of ops in file
        specs[5] = num_ops;                                     //number of operations in file
        char file_data_op[specs[5]];                            //data array for R or W
        int file_data_mem[specs[5]];                            //data array for mem location
        
        for (int i = 0; i < specs[5]; i++) {                    //set arrays to 0 or '\0'
            file_data_op[i] = '\0';
            file_data_mem[i] = 0;
        }
        
        do {
            if(i%2 != 0) {                                      //if its a memory location
                result = fscanf(fptr," %d",&temp2);             //scan and store result
                file_data_mem[j] = temp2;
                j++;                                            //increment array
            }
            else {                                              //else its a operations
                result = fscanf(fptr," %c",&temp);              //scan and store results
                file_data_op[k] = temp;
                k++;                                            //increment array
            }
            i++;                                                //increment checker
        } while (result != EOF);                                //do until file ends
    
        fclose(fptr);                                           //close the file
        simulator_output(specs, file_data_mem, file_data_op);   //generate output
                                                                
        printf("\nContinue? ('y' = yes, any other input = no): ");  //see if we continue
        scanf(" %c", &loop);                                    //scan for user input
    }
    return 0;
}

/* Function to query the user for needed information and the input file.
 * This data is stored in the specs array
 */
void query_user(int specs[], char filename[]){
    char replace_policy = NULL;
    char set_ass = NULL;
    
    printf("Enter the size of main memory in bytes: ");
    scanf("%d", &specs[0]);
    printf("Enter the size of the cache in bytes: ");
    scanf("%d", &specs[1]);
    printf("Enter the cache block/line size: ");
    scanf("%d", &specs[2]);
    printf("\nEnter the degree of set-associativity (input n for an n-way set-associative mapping):");
    scanf(" %c", &set_ass);
    if (set_ass == 'n') specs[3] = 0;                           //if user inputs 'n', store 0 in specs
    else specs[3] = set_ass - '0';                              //else store the char value - '0'
    
    printf("Enter the replacement policy (L = LRU, F = FIFO): ");
    scanf(" %c", &replace_policy);
    if (replace_policy == 'L') specs[4] = 1;                    //if user inputs L, store 1 in specs array
    if (replace_policy == 'F') specs[4] = 2;                    //if user inputs F, store 2 in specs array
    
    printf("Enter the name of the input file containing the list of memory references generated by the CPU: ");
    scanf("%s", filename);

    return;
}

//Calcuates the values for the first chuck of output, also creates thh cache data structure
void simulator_output(int specs[], int file_data_mem[], char file_data_op[]){
    int address_lines = 0, offset_bits = 0, index_bits = 0, tag_bits = 0;
    double total_size = 0.0;
    
    address_lines = log(specs[0])/log(2);                       //calculate the number of address lines
    int num_cache_blk = specs[1]/specs[2];                      //calculate the number of cache blocks
    tag_bits = log(num_cache_blk)/log(2);                       //calculate the number of tag bits
    
    int (*cache)[7] = malloc(sizeof *cache * num_cache_blk * 7);
    /* 0 = cache blkNum
     * 1 = dirty
     * 2 = valid
     * 3 = tag
     * 4 = data
     * 5 = set number
     * 6 = LRU_helper
     */
     
    if (cache) {                                                //if cache was malloc successfully
    size_t i, j;                                                //loop variables
    for (i = 0; i < num_cache_blk; i++)                         //loop through each block
        for (j = 0; j < 7; j++)                                 //loop through each sub array
            cache[i][j] = 0;                                    //set to 0
    }
    
    for(int k = 0; k<(num_cache_blk);k++){                      //set cache blk numbers to the 
        cache[k][0] = k;                                        //correct value
    }
    
    if (specs[3] == 1){                                         //direct mapping
        offset_bits = log(specs[2])/log(2);                     //calc offset size
        index_bits = log(num_cache_blk)/log(2);                 //index size with log
        tag_bits = address_lines - offset_bits - index_bits;    //tag bits
        total_size = specs[1] + ((tag_bits*num_cache_blk)+num_cache_blk+num_cache_blk)/8;
    }
    else if(specs[3]>1){                                        //set-associative
        offset_bits = log(specs[2])/log(2);                     //offset
        index_bits = log(num_cache_blk/specs[3])/log(2);        //index
        tag_bits = address_lines - offset_bits - index_bits;    //tag
        total_size = specs[1] + ((tag_bits*num_cache_blk)+num_cache_blk+num_cache_blk)/8;

        int set_num = 0;                                        
        int j = 0;

        for (int i = 0; i < num_cache_blk; i++) {               //assign each cache block set #
            cache[i][5] = set_num;
            j++;
            if (j%specs[3] == 0) set_num++;
        }
    }
    else if(specs[3]==0){                                       //full associative
        offset_bits = log(specs[2])/log(2);                     //offset, no index
        tag_bits = address_lines - offset_bits;                 //tag
        total_size = specs[1] + ((tag_bits*num_cache_blk)+(num_cache_blk*2))/8.0;
    }
    
    printf("\nSimulator Output:\nTotal address lines required = %d\n", address_lines);
    printf("Number of bits for offset = %d\nNumber of bits for index = %d\n", offset_bits, index_bits);
    printf("Numbers of bits for tag = %d\nTotal cache size required = %.2f bytes\n", tag_bits, total_size);
    
    print_table_1(specs, file_data_mem, file_data_op, tag_bits, cache); //print table 1
    print_table_2(specs, file_data_mem, tag_bits, cache);       //print final cache status
    
    return;
}

//Function to print the first table. Does the leg work to build the cache
void print_table_1(int specs[], int file_data_mem[], char file_data_op[], int tag_bits, int cache[][7]){
    char str[120];
    sprintf(str,"\nmain memory address\tmm blk #\tcm set #\tcm blk #\thit/miss\n");
    printf("%s", str);                                          //print the header for table 1

    double hits = 0;
    
    int address_lines = log(specs[0])/log(2);                   //calc # of address lines
    int *mm_blk_num = malloc(sizeof(int) * specs[5]);           //array to store the values
    int *cm_set_num = malloc(sizeof(int) * specs[5]);           //associated with the memory
    int *cm_blk_num = malloc(sizeof(int) * specs[5]);           //locations from the file
    int *hit_miss = malloc(sizeof(int) * specs[5]);                                      

    int fifo_help = 0;

    for (int i = 0; i < specs[5]; i++) {                        //set all arrays to 0
        mm_blk_num[i] = 0;
        cm_set_num[i] = 0;
        mm_blk_num[i] = 0;
        hit_miss[i] = 0;
    }
    
    if(specs[3] == 1) {                                         //direct mapping 
        int num_cm_sets = specs[1]/specs[2];                    //calc # of cm sets
        int write_back_help = 0;                                //helper
        
        for (int i=0; i<specs[5];i++){                          //loop through values from file
            mm_blk_num[i] = (file_data_mem[i]/specs[2]);        //calc main memory blk #
            cm_set_num[i] = mm_blk_num[i] % num_cm_sets;        //calc cache set #
            cm_blk_num[i] = cm_set_num[i];                      //calc cache blk #
            
            uint64_t temp9 = file_data_mem[i];                  //get main memory address
            int shift = address_lines - tag_bits;               //find shift amount
            uint64_t temp_tag = temp9 >> shift;                 //shift to find the tag

            if (cache[cm_blk_num[i]][2] == 0){                  //if cache set is unused
                cache[cm_blk_num[i]][2] = 1;                    //set valid bit
                cache[cm_blk_num[i]][3] = temp_tag;             //set tag
                cache[cm_blk_num[i]][4] = mm_blk_num[i];        //set data 
                hit_miss[i] = 0;                                //miss
                
                writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
            }
            else if (cache[cm_blk_num[i]][2] == 1 && cache[cm_blk_num[i]][3] == temp_tag){
                hit_miss[i] = 1;                                //hit
                
                writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
            }
            else if (cache[cm_blk_num[i]][2] == 1 && cache[cm_blk_num[i]][3] != temp_tag){
                //replace current values
                cache[cm_blk_num[i]][2] = 1;                    //valid bit to 1
                cache[cm_blk_num[i]][3] = temp_tag;             //set new tag
                cache[cm_blk_num[i]][4] = file_data_mem[i]/specs[2];    //mm blk
                hit_miss[i] = 0;                                //miss
                
                writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
            }
        
            //print out the first table 1 row at a time based on file data
            printf("%19d\t%8d\t%8d\t%8d\t", file_data_mem[i], mm_blk_num[i], cm_set_num[i], cm_blk_num[i]);
            if (hit_miss[i] == 1) {                             //if there was a hit
                printf("%8s\n","hit");                          //print hit
                hits++;
            }
            else {
                printf("%8s\n", "miss");
            }
        }
    }
    else if(specs[3] > 1){                                      //set-associative mapping
        int num_cache_blk = specs[1]/specs[2];                  //calcualte the number of cache blks
        int num_cm_sets = num_cache_blk/specs[3];               //calculate the number of sets

        int fifo[num_cm_sets];                                  //fifo marker array
        for (int a = 0; a < num_cm_sets; a++) {
            fifo[a] = 0;                                        //zero the array
        }
        
        int write_back_help = 0;                                //write_back helper
        int replace_help = 0;                                   //replacement policy helper
        
        for (int i = 0; i < specs[5]; i++){                     //loop through the number of ops in file
            mm_blk_num[i] = (file_data_mem[i]/specs[2]);        //calc mm blk number
            cm_set_num[i] = mm_blk_num[i]%num_cm_sets;          //calc number of sets
            
            uint64_t temp9 = file_data_mem[i];                  //get address location
            int shift = address_lines - tag_bits;               //number of bits needed to shift out
            uint64_t temp_tag = temp9 >> shift;                 //shift out bits to get tag

            replace_help = 0;// = 0;
            for (int j = 0; j < num_cache_blk; j++) {           //search through the cache
                if (cache[j][5] == cm_set_num[i]) {             //if we're in right cache set
                    if (cache[j][2] == 0) {                     //if not used cache blk
                        cache[j][2] = 1;                        //set valid bit
                        cache[j][3] = temp_tag;                 //set tag value
                        cache[j][4] = mm_blk_num[i];            //set memory blk
                        cache[j][6]++;                          //LRU help
                        hit_miss[i] = 0;                        //hit or a miss
                        cm_blk_num[i] = j;                      //set block number

                        writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                        replace_help = 1;                       //replace not needed
                        
                        break;                                  //save time by exiting loop  
                    }
                    else if (cache[j][2] == 1 && cache[j][3] == temp_tag) {
                        hit_miss[i] = 1;                        //hit
                        cm_blk_num[i] = j;                      //set blk number
                        cache[j][6]++;                          //replace help
                        writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                        replace_help = 1;                       //repalce not needed
                        break;                                  //save time by exiting loop
                    }
                }
            }
            if (replace_help == 0) {                            //if replace needed
                if (specs[4] == 2) {                            //FIFO
                    for (int k = 0; k < num_cache_blk; k++) {   //search cache
                        if (cache[k][5] == cm_set_num[i]) {     //if in right cache set
                            int offset = k + fifo[cm_set_num[i]];   //first blk in set + fifo marker
                            cache[offset][2] = 1;               //set valid bit
                            cache[offset][3] = temp_tag;        //set tag value
                            cache[offset][4] = mm_blk_num[i];   //set mm blk num
                            hit_miss[i] = 0;                    //miss
                            cm_blk_num[i] = i+offset;           //set blk number

                            fifo[cm_set_num[i]]++;              //increment fifo marker
                            if (fifo[cm_set_num[i]] > specs[3]) {
                                fifo[cm_set_num[i]] = 0;        //if marker is past blk number, reset
                            }
                           
                            writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                            replace_help = 1;                   //replace not needed                   
                            break;                              //save time by exiting loop
                        }
                    }
                }
                else if (specs[4] == 1) {                       //LRU
                    int min = 100000;                           //never going to have more than 100000 ops per blk
                    int k = 0;
                    for (k = 0; k < num_cache_blk; k++) {       //search cache
                        if (cache[k][5] == cm_set_num[i]) {     //if in right set
                            if (cache[k][6] < min) {
                                min = cache[k][6];              //find lowest value
                            }
                        }
                    }
                    for (k = 0; k < num_cache_blk; k++) {       //search cache
                        // if in right set and at LRU blk
                        if (cache[k][5] == cm_set_num[i] && cache[k][6] == min) {     
                            cache[k][2] = 1;                    //set valid bit
                            cache[k][3] = temp_tag;             //set tag value
                            cache[k][4] = mm_blk_num[i];        //set memory blk
                            cache[k][6]++;                      //LRU help
                            hit_miss[i] = 0;                    //hit or a miss
                            cm_blk_num[i] = k;                  //set block number

                            writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                            replace_help = 1;                   //replace not needed
                        
                            break;                              //save time by exiting loop
                        }
                    }
                }
            }
            //print out the first table 1 row at a time based on file data
            printf("%19d\t%8d\t%8d\t", file_data_mem[i], mm_blk_num[i], cm_set_num[i]);
            printf("%d ", cm_set_num[i]*specs[3]);              //print first possible cache blk
            printf("to %d ", (cm_set_num[i]*specs[3])+specs[3]-1);  //print last possible cache blk
                
            if (hit_miss[i] == 1) {
                printf("\t\t%8s\n","hit");
                hits++;
            }
            else {
                printf("\t\t%8s\n", "miss");
            }
        }
    }
    else if(specs[3] == 0){                                     //fully-associative mapping
        int num_cm_sets = 1;                                    //set # of sets to 1
        int num_cache_blk = specs[1]/specs[2];                  //calc the value of cache blocks
        int cache_entries = 0;                                  //entires in cache is 0

        int write_back_help = 0;                                //write-back helper
        
        for (int i = 0; i < specs[5]; i++){                     //loop through the num of ops in file
            mm_blk_num[i] = (file_data_mem[i]/specs[2]);        //calc main memory blk #
            cm_set_num[i] = num_cm_sets;                        //set cache set # to 1
            
            uint64_t temp9 = file_data_mem[i];                  //get mm address
            int shift = address_lines - tag_bits;               //find out shift amount to get tag
            uint64_t temp_tag = temp9 >> shift;                 //get tag

            int j = 0;
            while(j < (specs[1]/specs[2])) {                    //while cache is not full
                if (cache[j][2] == 0) {                         //if unused blk
                    cache[j][2] = 1;                            //set valid bit to 1
                    cache[j][3] = temp_tag;                     //set tag
                    cache[j][4] = mm_blk_num[i];                //set data
                    cache[j][6]++;                              //increment LRU helper
                    hit_miss[i] = 0;                            //miss
                    cm_blk_num[i] = j;                          //set blk number for table
                    cache_entries++;                            //increment number of entries

                    writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                    break;                                      //break out of loop to save time
                }
                else if (cache[j][2] == 1 && cache[j][3] == temp_tag) { //if hit
                    hit_miss[i] = 1;                            //hit
                    cm_blk_num[i] = j;                          //set blk number for table
                    cache[j][6]++;                              //increment LRU helper
                                        
                    writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                    break;                                      //break to save time
                }
                j++;
            }

            if (j == num_cache_blk) {                           //if cache full
                if (specs[4] == 2) {                            //FIFO Replacement
                    cache[fifo_help][2] = 1;                    //use fifo_help to find cm blk
                    cache[fifo_help][3] = temp_tag;             //set tag
                    cache[fifo_help][4] = mm_blk_num[i];        //set data
                    hit_miss[i] = 0;                            //miss
                    cm_blk_num[i] = j;                          //set blk # for table
					writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                    fifo_help++;                                //increment fifo help marker
                    if (fifo_help >= (specs[1]/specs[2])) {     //if marker goes beyond scope
                        fifo_help = 0;                          //reset to 0
                    }
                }
                else if (specs[4] == 1) {                       //LRU replacement
                    int min = 100000;                           //compare value
                    int h = 0, k = 0;                           //loop variables

                    for (h = 0; h < num_cache_blk; h++){        //find lowest value for LRU
                        if (cache[h][6] < min) {
                                min = cache[h][6];              //find lowest value
                        }
                    }
                    for (k = 0; k < num_cache_blk; k++) {       //search cache
                        // if in right set and at LRU blk
                        if (cache[k][6] == min) {     
                            cache[k][2] = 1;                    //set valid bit
                            cache[k][3] = temp_tag;             //set tag value
                            cache[k][4] = mm_blk_num[i];        //set memory blk
                            cache[k][6]++;                      //LRU help
                            hit_miss[i] = 0;                    //hit or a miss
                            cm_blk_num[i] = k;                  //set block number

                            writeback(file_data_op, cache, write_back_help, mm_blk_num, cm_blk_num, i);
                            break;                              //save time by exiting loop
                        }
                    }

                }
            }   
            //print out the first table 1 row at a time based on file data
            printf("%19d\t%8d\t%8d\t%8d\t", file_data_mem[i], mm_blk_num[i], cm_set_num[i], cm_blk_num[i]);
                if (hit_miss[i] == 1) {
                    printf("%8s\n","hit");
                    hits++;
                }
                else {
                    printf("%8s\n", "miss");
                }
        }
        
    }
    
    double best_hits = best_hit_rate(file_data_mem, specs);     //calc best possible # of hits
    double best_hit_rate_value = (best_hits/specs[5])*100;      //calc best hit rate
    double hit_rate = (hits/specs[5])*100;                      //cacl hit rate

    printf("\nHighest possible hit rate = %.0f/%d = %.2f%%\n", best_hits, specs[5] , best_hit_rate_value);
    printf("Actual hit rate = %.0f/%d = %.2f%%\n", hits, specs[5], hit_rate);
    return;
}

//Function to print out the final cache values
void print_table_2(int specs[], int file_data_mem[], int tag_bits, int cache[][7]){
    char str[120];
    
    printf("\nFinal \"status\" of the cache:");
    sprintf(str,"\nCache blk #\tdirty bit\tvalid bit\ttag\tData\t\n");
    printf("%s", str);                                          //print table headers
    char *tag_hold = malloc(sizeof(char) * (tag_bits+1));       //xxxx for table
    for(int i = 0; i<tag_bits; i++) {                           //get right number of 'x'
        tag_hold[i] = 'x';                          
    }
    tag_hold[tag_bits+1] = '\0';                                //end tag hold string
    char mem_hold[9] = "mm blk #\0";                            //formatting
    int cache_blk = specs[1]/specs[2];                          //# of cache blocks

    for(int i = 0; i<cache_blk; i++){                           //loop through each cache block
        printf("%11d\t%9d\t%9d\t",cache[i][0],cache[i][1],cache[i][2]);
        if (cache[i][2] == 1) {                                 //if used
            printf("%0*d\t%4s %d\n",tag_bits,binary_conversion(cache[i][3]),mem_hold,cache[i][4]);
        }
        else{                                                   //else not used
            printf("%s\t%s\n",tag_hold,tag_hold);               //print placeholders
        }
    }
    tag_hold[0] = '\0';                                         //set tag hold to empty for next file
    return;
}

/* Function to convert the tag as an in value into binary
 * Takes in an int and returns the binary numbers
 */
int binary_conversion(int num) {
    if (num == 0) {
        return 0;
    }

    else {
        return (num % 2) + 10 * binary_conversion(num / 2);
    }
}

/* Function implement the write-back policy
 * if the corresponding operation (given with i) is a W, write the dirty bit to 1
 * and set the write back helper to the last mm_blk written
 * else, if differing main memory block numbers, clear the dirty bit
 */
void writeback(char file_data_op[], int cache[][7], int write_back_help, int mm_blk_num[], int cm_blk_num[], int i){
    if (file_data_op[i] == 'W') {                               //if its a write
        cache[cm_blk_num[i]][1] = 1;                            //set dirty bit
        write_back_help = mm_blk_num[i];                        //set helper
    }
    else {                                                      //clear dirty bit if mm_blk changed
        if(write_back_help != mm_blk_num[i]) cache[cm_blk_num[i]][1] = 0;
    }
}

/* Function to calculate the best hit rate
 * takes in the data from the files, counts the number of repeated values
 * and returns it as a double.
 */
double best_hit_rate(int file_data_mem[], int specs[]){
    double hits = 0.0;
    int temp = 0.0;
    int temp2 = 0.0;
    for (int i = 0; i < specs[5]; i++){                         //loop through array of memory locations
        temp = (file_data_mem[i]/specs[2]);                     //get blk number
        for (int j = 0; j < i; j++){                            //loop again
            temp2 = (file_data_mem[j]/specs[2]);                //get comparator blk number
            if ( i != j && temp == temp2) {                     //if not the same location
                hits++;                                         //increment hits
                break;                                          
            }
        }
    }
    return hits;
}
